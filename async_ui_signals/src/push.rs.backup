#![feature(generic_associated_types)]
#![feature(unsize)]
#![forbid(unsafe_op_in_unsafe_fn)]

use std::{
    cell::RefCell,
    collections::BTreeSet,
    marker::{PhantomData, Unsize},
    ops::{Index, Range},
    task::Waker,
};

trait Listenable<V>
where
    V: ?Sized,
{
    unsafe fn add_listener<'s, 'z>(&'s self, listener: &'z V)
    where
        Self: 'z;
}

trait Pushable<I> {
    fn push<'s>(&'s self, input: I);
}

struct SignalSource<T> {
    value: RefCell<T>,
    listeners: RefCell<(BTreeSet<*const dyn for<'x> Pushable<&'x T>>, Option<Waker>)>,
}

impl<T> SignalSource<T> {
    fn new(value: T) -> Self {
        Self {
            value: RefCell::new(value),
            listeners: Default::default(),
        }
    }
}

impl<'v, T, V> Listenable<V> for SignalSource<T>
where
    V: ?Sized + Unsize<dyn for<'x> Pushable<&'x T> + 'v> + 'v,
{
    unsafe fn add_listener<'s, 'z>(&'s self, listener: &'z V)
    where
        Self: 'z,
    {
        let mut borrow = self.listeners.borrow_mut();
        let coerced: *const (dyn for<'x> Pushable<&'x T> + 'v) = listener;
        let transmuted: *const (dyn for<'x> Pushable<&'x T> + 'static) = unsafe {std::mem::transmute(coerced)};
        borrow.0.insert(transmuted);
    }
}

trait Mapper {
    type Input<'i>
    where
        Self: 'i;
    type Output<'o>
    where
        Self: 'o;
    fn map<'m, 's>(&'s self, input: Self::Input<'m>) -> Self::Output<'m>
    where
        Self: 'm;
}

struct SignalMap<'p, M>
where
    M: Mapper + 'p,
{
    mapper: M,
    listener: RefCell<Option<*const dyn for<'x> Pushable<M::Output<'x>>>>,
    parent: &'p (dyn Listenable<dyn for<'x> Pushable<M::Input<'x>>> + 'p),
}

impl<'p, M> SignalMap<'p, M>
where
    M: Mapper + 'p,
{
    fn new<P>(mapper: M, parent: &'p P) -> Self
    where
        P: for<'k> Listenable<dyn for<'x> Pushable<M::Input<'x>> + 'k> + 'p,
    {
        Self {
            mapper,
            listener: Default::default(),
            parent,
        }
    }
}

impl<'v, 'p, M, V> Listenable<V> for SignalMap<'p, M>
where
    M: Mapper + 'p,
    V: ?Sized + Unsize<dyn for<'x> Pushable<M::Output<'x>> + 'v> + 'v,
{
    unsafe fn add_listener<'s, 'z>(&'s self, listener: &'z V)
    where
        Self: 'z,
    {
        let coerced: *const (dyn for<'x> Pushable<M::Output<'x>> + 'v) = listener;
        let transmuted: *const (dyn for<'x> Pushable<M::Output<'x>> + 'static) = unsafe {std::mem::transmute(coerced)};
        *self.listener.borrow_mut() = Some(transmuted);
    }
}

impl<'i, 'p, M> Pushable<M::Input<'i>> for SignalMap<'p, M>
where
    M: Mapper + 'p,
{
    fn push<'s>(&'s self, input: M::Input<'i>) {
        let output = self.mapper.map(input);
        if let Some(listener) = self.listener.borrow().as_ref() {
            let listener = unsafe { &**listener };
            listener.push(output);
        }
    }
}

// struct SignalCache<C>
// {
//     cache: RefCell<Option<C>>,
//     listener: RefCell<Option<*const dyn for<'x> Pushable<&'x C>>>
// }

// impl<'v, C, V> Listenable<V> for SignalCache<C>
// where
//     V: ?Sized + for<'x> Pushable<&'x C> + 'v
// {
//     fn request<'s>(&'s self) {

//     }
// }

// impl<'x, C> Pushable<C> for SignalCache<C> {
//     fn push<'s>(&'s self, input: C) {
//         let mut borrow = self.cache.borrow_mut();
//         let reference = borrow.insert(input);
//         if let Some(listener) = self.listener.borrow().as_ref() {
//             let listener = unsafe {&**listener};
//             listener.push(reference);
//         }
//     }
// }

fn play() {
    let s = String::from("hello world");
    let source = SignalSource {
        value: RefCell::new(s),
        listeners: Default::default(),
    };

    struct SliceMapper<T: ?Sized + Index<Range<usize>>>(Range<usize>, PhantomData<T>);
    impl<T: ?Sized + Index<Range<usize>>> Mapper for SliceMapper<T> {
        type Input<'i> = &'i T where Self: 'i;
        type Output<'o> = &'o T::Output where Self: 'o;
        fn map<'x>(&self, input: Self::Input<'x>) -> Self::Output<'x> {
            &input[self.0.clone()]
        }
    }

    let mapper: SliceMapper<String> = SliceMapper(1..5, PhantomData);

    // let mapped = SignalMap {
    //     parent: &source,
    //     mapper,
    //     listener: Default::default()
    // };
    let mapped = SignalMap::new(mapper, &source);

    let mapper2: SliceMapper<str> = SliceMapper(1..3, PhantomData);
    let mapped2 = SignalMap::new(mapper2, &mapped);
    // let mapped2 = SignalMap {
    //     parent: &mapped as _,
    //     mapper: mapper2,
    //     listener: Default::default()
    // };
}